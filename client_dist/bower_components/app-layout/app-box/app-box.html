<link rel="import" href="../../polymer/polymer.html"><link rel="import" href="../../iron-flex-layout/iron-flex-layout.html"><link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html"><link rel="import" href="../app-scroll-effects/app-scroll-effects-behavior.html"><dom-module id="app-box"><style>

    :host {
      display: block;
      position: relative;
    }

    #background {
      @apply(--layout-fit);
      overflow: hidden;
      height: 100%;
    }

    #backgroundFrontLayer {
      pointer-events: none;
      background-size: cover;
      min-height: 100%;
      @apply(--app-box-background-front-layer);
    }

    #contentContainer {
      position: relative;
      height: 100%;
      width: 100%;
    }

    :host([disabled]),
    :host([disabled]) #backgroundFrontLayer {
      transition: none !important;
    }

  </style><template><div id="background"><div id="backgroundFrontLayer"><content select="[background]"></content></div></div><div id="contentContainer"><content id="content"></content></div></template><script>
    Polymer({

      is: 'app-box',

      behaviors: [
        Polymer.AppScrollEffectsBehavior,
        Polymer.IronResizableBehavior
      ],

      listeners: {
        'iron-resize': '_resizeHandler'
      },

      /**
       * The current scroll progress.
       *
       * @type {number}
       */
      _progress: 0,

      attached: function() {
        this.resetLayout();
      },

      /**
       * Resets the layout. This method is automatically called when the element is attached to the DOM.
       *
       * @method resetLayout
       */
      resetLayout: function() {
        this.debounce('_resetLayout', function() {
          // noop if the box isn't in the rendered tree
          if (this.offsetWidth === 0 && this.offsetHeight === 0) {
            return;
          }

          var scrollTop = this._clampedScrollTop;
          var savedDisabled = this.disabled;

          this.disabled = true;
          this._elementTop = this._getElementTop();
          this._elementHeight = this.offsetHeight;
          this._cachedScrollTargetHeight = this._scrollTargetHeight;
          this._setUpEffect();
          this._updateScrollState(scrollTop);
          this.disabled = savedDisabled;
        }, 1);
      },

      _getElementTop: function() {
        var currentNode = this;
        var top = 0;

        while (currentNode && currentNode !== this.scrollTarget) {
          top += currentNode.offsetTop;
          currentNode = currentNode.offsetParent;
        }
        return top;
      },

      _updateScrollState: function(scrollTop) {
        if (this.isOnScreen()) {
          var viewportTop = this._elementTop - scrollTop;
          this._progress = 1 - (viewportTop + this._elementHeight) / this._cachedScrollTargetHeight;
          this._runEffects(this._progress, scrollTop);
        }
      },

      /**
       * Returns true if this app-box is on the screen.
       * That is, visible in the current viewport.
       *
       * @method setup
       * @return {boolean}
       */

      isOnScreen: function() {
        return this._elementTop < this._scrollTop + this._cachedScrollTargetHeight
            && this._elementTop + this._elementHeight > this._scrollTop;
      },

      _resizeHandler: function() {
        this.resetLayout();
      },

      /**
       * Returns an object containing the progress value of the scroll effects.
       *
       * @method getScrollState
       * @return {Object}
       */
      getScrollState: function() {
        return { progress: this._progress };
      }

    });
  </script></dom-module>